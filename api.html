<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>noderJS - API</title>
<meta charset="utf-8">
<link href="images/favicon.ico" type="image/ico"
	rel="shortcut icon">
<link rel="stylesheet" href="css/all.css" type="text/css">
<link rel="stylesheet" href="css/noder.css" type="text/css">
<link rel="stylesheet" href="css/snippets/style.css" type="text/css">
<link rel="stylesheet" href="css/snippets/highlight_skin.css" type="text/css">
<!-- font-awesome -->
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<!--[if IE 7]>
    <link rel="stylesheet" href="css/versionselect.css" type="text/css"><![endif]-->
<link rel="stylesheet" href="css/documentation.css" type="text/css">
<!--[if lt IE 9]>
    <script type="text/javascript" src="js/iemap.js"></script>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js" type="text/javascript" charset="utf-8"></script>
    <style>.ie-hidden {display:none;}</style><![endif]-->
<!--[if lt IE 8]>
    <link href="css/ie7.css" rel="stylesheet" type="text/css"><![endif]-->
</head>
<body class="documentation">
	<header id="header">
    <div class="logo">
      <h5>
        <a href="./index.html"><img alt="noderJS"
          src="images/logo-nav.png"></a>
      </h5>
    </div>
    <nav>
      <a class="getstarted " href="./getstarted.html">Get started</a>
      <a class="configuration " href="./configuration.html">Configuration options</a>
      <a class="api selected" href="./api.html">API</a>
      <a class="build " href="./build.html">Contribute</a>
      <a class="packaging " href="./packaging.html">Packaging</a>
    </nav>
  </header>
	<div class="content-wrapper">
		<section class="content">
			<div class="wrapper">
				<div class="columns main-page one">
					<article class="column"><h1 id="noderjs-api">noderJS API</h1>
<p>This page details the public API exposed by noderJS.</p>
<h2 id="module-variables">Module variables</h2>
<p>Inside a module loaded with noderJS, the following variables are automatically available.
They are compatible with the corresponding variables available from a module loaded
in <a href="http://nodejs.org/api/globals.html">Node.js</a>:</p>
<ul>
<li><a href="http://nodejs.org/api/globals.html#globals_global">global</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_require_resolve">require.resolve</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_require_cache">require.cache</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_require">require.main</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_exports">exports and module.exports</a></li>
<li><a href="http://nodejs.org/api/modules.html#modules_module_filename">module.filename</a> and <a href="http://nodejs.org/api/modules.html#modules_module_id">module.id</a></li>
<li><a href="http://nodejs.org/api/modules.html#modules_module_loaded">module.loaded</a></li>
<li><a href="http://nodejs.org/api/modules.html#modules_module_require_id">module.require</a></li>
<li><a href="http://nodejs.org/api/modules.html#modules_module_parent">module.parent</a></li>
<li><a href="http://nodejs.org/api/modules.html#modules_module_children">module.children</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_filename">__filename</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_dirname">__dirname</a></li>
</ul>
<h2 id="noder-global-variable">noder global variable</h2>
<p>noderJS creates a global variable called <code>noder</code> (its name is <a href="configuration.html">configurable</a>).
This variable corresponds to the root module that is automatically created by noderJS.
All the properties usually available on the <code>module</code> variable in a module (and listed in the previous section)
are also available on the <code>noder</code> global variable. Moreover, the following shortcuts are also available for
convenience (they are documented later in this page):</p>
<ul>
<li><code>noder.asyncRequire = noder.require(&quot;noder-js/asyncRequire&quot;)</code></li>
<li><code>noder.define = noder.require(&quot;noder-js/currentContext&quot;).define</code></li>
<li><code>noder.execute = noder.require(&quot;noder-js/currentContext&quot;).jsModuleExecute</code></li>
<li><code>noder.createContext = noder.require(&quot;noder-js/context&quot;).createContext</code></li>
</ul>
<p>The <code>noder</code> global variable is especially intended to be used from any JavaScript code in the page that is not
loaded through noderJS (and thus does not have access to its own <code>module</code> and <code>require</code> variables). Unless there
is a good reason, it should not be used inside a module loaded through noderJS, as, for better compatibility with
CommonJS standards, it is better to use the local <code>module</code> and <code>require</code> variables.</p>
<p>Note that the <code>noder</code> global variable is especially useful for debugging: you can inspect the noderJS cache
and access all modules through <code>noder.require.cache</code>.</p>
<h2 id="asynchronous-module-loading">Asynchronous module loading</h2>
<h4 id="usage">Usage</h4>
<p>In addition to the basic synchronous standard version of require (which is equivalent to a static dependency), noderJS
provides a promises-based <code>asyncRequire</code> method to load a module asynchronously:</p>
<p><strong>asyncRequire (modulePath1, modulePath2...) : Promise</strong></p>
<p><code>asyncRequire</code> accepts any number of module paths as parameters and returns a promise giving access to the array of
the <code>exports</code> objects of all requested modules.</p>
<p>It can be used in the following way:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">'noder-js/asyncRequire'</span>);

<span class="comment">// asyncRequire preloads and executes the modules given as parameters and returns a promise.</span>
<span class="comment">// As the promise result is an array, it is possible to use "spread" to get each array item</span>
<span class="comment">// as a different argument of the given handler function:</span>
asyncRequire(<span class="string">"myFirstModule"</span>, <span class="string">"mySecondModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myFirstModule, mySecondModule)</span>{</span>
    <span class="comment">// Do something with myFirstModule and mySecondModule</span>
}, <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
    <span class="comment">// Do something in case of failure</span>
});</code></pre></div>
<h4 id="relative-paths">Relative paths</h4>
<p>If you want to use relative paths in <code>asyncRequire</code> (i.e. paths which are relative to the current module, in the same way
as it is possible with the synchronous <code>require</code>), you can either convert them to absolute paths with <code>require.resolve</code>
or you can create a local version of the <code>asyncRequire</code> method, as shown in the following two equivalent examples:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">'noder-js/asyncRequire'</span>);

<span class="comment">// Use require.resolve to convert the relative path into an absolute path:</span>
asyncRequire(<span class="built_in">require</span>.resolve(<span class="string">"./myRelativeModule"</span>)).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myRelativeModule)</span> {</span> <span class="comment">/* ... */</span> });</code></pre></div>
<div class='snippet'><pre><code class="lang-js"><span class="comment">// Use the create method to create a local version of the asyncRequire method which accepts relative paths:</span>
<span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">'noder-js/asyncRequire'</span>).create(module);

<span class="comment">// Then relative paths can be used directly:</span>
asyncRequire(<span class="string">"./myRelativeModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myRelativeModule)</span> {</span> <span class="comment">/* ... */</span> });</code></pre></div>
<h4 id="shortcut">Shortcut</h4>
<p>For convenience, the <code>asyncRequire</code> method is also available on the <code>noder</code> global variable, so that it is easy to load
some modules asynchronously, even from code which was not loaded through noderJS:</p>
<div class='snippet'><pre><code class="lang-js">noder.asyncRequire(<span class="string">"myModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myModule)</span>{</span> <span class="comment">/* ... */</span> }, <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span> <span class="comment">/* ... */</span> });</code></pre></div>
<h2 id="promises-library">Promises library</h2>
<p><a href="http://promisesaplus.com/">
<img src="http://promisesaplus.com/assets/logo-small.png" alt="Promises/A+ logo" title="Promises/A+ 1.1.1 compliant" align="right"
 style="margin-left:10px;" />
</a></p>
<p>noderJS heavily relies on promises. It includes a lightweight promise library which is compliant with the
<a href="http://promisesaplus.com">Promises/A+ specifications</a> version 1.1.1.</p>
<p>The integrated promise library can be accessed with:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);</code></pre></div>
<h3 id="promise-constructor">Promise constructor</h3>
<p><strong>new Promise (factoryFunction : function(resolve, reject)) : Promise</strong></p>
<p>Creates a new promise. The given <code>factoryFunction</code> gets a reference to the <code>resolve</code> and <code>reject</code> methods which
allow to resolve or reject the promise. If the <code>factoryFunction</code> raises an exception before calling <code>resolve</code>
or <code>reject</code>, the promise is rejected with the exception as the reason.</p>
<p>Here is a sample implementing a promise-based version of <code>setTimeout</code>:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);

<span class="keyword">var</span> setTimeoutWithPromise = <span class="function"><span class="keyword">function</span> <span class="params">(delay)</span> {</span>
   <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> {</span>
      setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
         resolve(<span class="number">7</span>);
      }, delay);
   });
};

console.log(<span class="string">"Before calling setTimeoutWithPromise"</span>);
setTimeoutWithPromise(<span class="number">1000</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> {</span>
   console.log(<span class="string">"In the callback. The result is: "</span> + result)
});
console.log(<span class="string">"After calling setTimeoutWithPromise"</span>);

<span class="comment">// The console should contain:</span>
<span class="comment">// Before calling setTimeoutWithPromise</span>
<span class="comment">// After calling setTimeoutWithPromise</span>
<span class="comment">// In the callback. The result is: 7</span></code></pre></div>
<p>Using the Promise constructor is the recommended way to create a promise. Alternatively, it is also possible
to use the <code>Promise.defer</code> method below.</p>
<h3 id="promise-defer-">Promise.defer()</h3>
<p><strong>Promise.defer () : Defer</strong></p>
<p>Creates a new defer. A defer is an object with 3 properties:</p>
<div class='snippet'><pre><code class="lang-js">{
   promise: promise, <span class="comment">/* Promise instance object (with the 'then' method) */</span>
   resolve: resolve, <span class="comment">/* Function to resolve the promise, with the specified value. */</span>
   reject: reject <span class="comment">/* Function to reject the promise, with the specified reason. */</span>
}</code></pre></div>
<p>Here is a sample re-implementing the <code>setTimeoutWithPromise</code> function from the previous section,
but using <code>Promise.defer()</code> instead of the promise constructor.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);

<span class="keyword">var</span> setTimeoutWithPromise = <span class="function"><span class="keyword">function</span> <span class="params">(delay)</span> {</span>
   <span class="keyword">var</span> defer = Promise.defer();
   setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      defer.resolve(<span class="number">7</span>);
   }, delay);
   <span class="keyword">return</span> defer.promise;
};</code></pre></div>
<h3 id="promise-resolve-">Promise.resolve()</h3>
<p><strong>Promise.resolve(valueOrPromise) : Promise</strong></p>
<p>If <code>valueOrPromise</code> is a noder-js promise, <code>Promise.resolve</code> returns it directly.</p>
<p>If <code>valueOrPromise</code> is an object or a function with a <code>thenSync</code> or <code>then</code>  method, it is considered as a promise and
<code>Promise.resolve</code> returns an equivalent noder-js promise.</p>
<p>Otherwise, <code>Promise.resolve</code> returns an already fulfilled promise, whose fulfillment value is <code>valueOrPromise</code>.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);

<span class="keyword">var</span> promiseInstance = Promise.resolve(<span class="number">7</span>);
promiseInstance.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> <span class="comment">/* here, value == 7 */</span> });
Promise.resolve(promiseInstance) <span class="comment">// this call returns promiseInstance</span>
Promise.resolve({
   then: <span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
      resolve(<span class="number">7</span>);
   }
}).then(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span> <span class="comment">/* here, value == 7 */</span> });</code></pre></div>
<h3 id="promise-reject-">Promise.reject()</h3>
<p><strong>Promise.reject(reason) : Promise</strong></p>
<p><code>Promise.reject</code> returns a rejected promise with the given reason.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);

Promise.reject(<span class="string">"error"</span>).catch(<span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> {</span> <span class="comment">/* here, reason == "error" */</span> });</code></pre></div>
<h3 id="promise-all-and-promise-allsettled-">Promise.all() and Promise.allSettled()</h3>
<p><strong>Promise.all (promiseOrValueArray : Array) : Promise</strong></p>
<p><strong>Promise.allSettled (promiseOrValueArray : Array) : Promise</strong></p>
<p><code>Promise.all</code> and <code>Promise.allSettled</code> return a promise that is fulfilled when all the given promises are fulfilled.</p>
<p><code>Promise.all</code> is the fail-fast version of <code>Promise.allSettled</code>:</p>
<ul>
<li>the promise returned by <code>Promise.allSettled</code> is rejected only when all promises are either fulfilled or rejected.</li>
<li>the promise returned by <code>Promise.all</code> is rejected as soon as any promise is rejected, without waiting for other
promises to either be fulfilled or rejected.</li>
</ul>
<p>Apart from that timing difference, <code>Promise.all</code> and <code>Promise.allSettled</code> are otherwise fully equivalent.</p>
<p>Here is an example showing how to use <code>Promise.all</code>:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
<span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">"noder-js/asyncRequire"</span>);

Promise.all([<span class="string">"simple value"</span>, asyncRequire(<span class="string">"myModule1"</span>, <span class="string">"myModule2"</span>)]).spread(<span class="function"><span class="keyword">function</span> <span class="params">(simpleValue, myModules)</span> {</span>
   <span class="comment">// here:</span>
   <span class="comment">// simpleValue == "simple value"</span>
   <span class="comment">// myModules is an array containing the exports objects of myModule1 and myModule2</span>
}, <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
   <span class="comment">// this function is called in case there is an error while loading myModule1 or myModule2</span>
});</code></pre></div>
<h3 id="promiseinstance-then-and-its-shortcuts">promiseInstance.then() and its shortcuts</h3>
<p><strong>promiseInstance.then(onFulfilled : function (value), onRejected : function (reason)) : Promise</strong></p>
<p><code>promiseInstance.then</code> adds a fulfillment and a rejection handler to the promise, and returns a new promise
resolving to the return value of the called handler.</p>
<p>If <code>onFulfilled</code> is null (or not a function), and <code>promiseInstance</code> is fulfilled, the returned promise is
fulfilled with the same fulfillment value.</p>
<p>If <code>onRejected</code> is null (or not a function), and <code>promiseInstance</code> is rejected, the returned promise is rejected
with the same reason.</p>
<p>If both <code>onFulfilled</code> and <code>onRejected</code> are null (or not functions), <code>promiseInstance</code> itself is returned.</p>
<p>The following shortcuts for <code>promiseInstance.then</code> are available:</p>
<p><strong>promiseInstance.catch(onRejected : function (reason)) : Promise</strong></p>
<div class='snippet'><pre><code class="lang-js">promiseInstance.catch(onRejected);
<span class="comment">// is equivalent to:</span>
promiseInstance.then(<span class="literal">null</span>, onRejected);</code></pre></div>
<p><strong>promiseInstance.finally(handler : function (value)) : Promise</strong></p>
<div class='snippet'><pre><code class="lang-js">promiseInstance.finally(handler);
<span class="comment">// is equivalent to:</span>
promiseInstance.then(handler, handler);</code></pre></div>
<p><strong>promiseInstance.spread(onFulfilled : function (value1, value2 ...), onRejected : function (reason)) : Promise</strong></p>
<p><code>promiseInstance.spread</code> can be used when the fulfillment value is expected to be an array.</p>
<div class='snippet'><pre><code class="lang-js">promiseInstance.spread(onFulfilled, onRejected);
<span class="comment">// is equivalent to:</span>
promiseInstance.then(<span class="function"><span class="keyword">function</span><span class="params">(array)</span> {</span>
  <span class="comment">// each item of the array is passed as a different argument to onFulfilled:</span>
  <span class="keyword">return</span> onFulfilled.apply(<span class="literal">null</span>, array);
}, onRejected);</code></pre></div>
<p><strong>promiseInstance.done(onFulfilled : function (value), onRejected : function (reason))</strong></p>
<p>The <code>done</code> method is equivalent to <code>then</code> except that it does not return a new promise, and it reports any error by throwing it
asynchronously.
It is often used without any argument to end a promises chain so that any unhandled error in the chain is properly
reported instead of being silently ignored.</p>
<p>For example, with the folling code, if an error occurs when loading <code>myModule</code>, or in the function which uses <code>myModule</code>,
the error is silently ignored:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">"noder-js/asyncRequire"</span>);

asyncRequire(<span class="string">"myModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myModule)</span> {</span>
  <span class="comment">// do something with myModule</span>
}); <span class="comment">// without .done(), errors in this promises chain are silently ignored</span></code></pre></div>
<p>Adding <code>.done()</code> at the end of the promises chain makes sure any unhandled error happening in the promises chain is properly reported:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">"noder-js/asyncRequire"</span>);

asyncRequire(<span class="string">"myModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myModule)</span> {</span>
  <span class="comment">// do something with myModule</span>
}).done(); <span class="comment">// with .done(), errors are properly reported</span></code></pre></div>
<h3 id="promiseinstance-thensync-and-its-shortcuts">promiseInstance.thenSync() and its shortcuts</h3>
<p>Following the <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+ specifications</a>, the <code>promiseInstance.then</code> method never
calls its handlers synchronously. The same applies to the associated <code>spread</code>, <code>catch</code>, <code>finally</code> and <code>done</code> shortcuts.</p>
<p>However, in some cases, it can be useful to avoid code duplication by handling both the asynchronous and the synchronous cases with
the same code. For example, noder-js itself can be configured to use either synchronous or asynchronous XHR requests and uses the same
code to handle both cases, without adding asynchronism uselessly.</p>
<p>For this to be possible, noder-js provides the <code>thenSync</code>, <code>spreadSync</code>, <code>catchSync</code>, <code>finallySync</code> and <code>doneSync</code> methods which behave
exactly as their <code>then</code>, <code>spread</code>, <code>catch</code>, <code>finally</code> and <code>done</code> counterparts, except that, in case the promise is already fulfilled or
rejected at the time the <code>xSync</code> method is called, the corresponding handler is called synchronously.</p>
<p>Here is an example which shows the difference between <code>then</code> and <code>thenSync:</code></p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> thenValue, thenSyncValue;
<span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
<span class="keyword">var</span> myPromise = Promise.resolve(<span class="number">7</span>);

<span class="comment">// myPromise is already fulfilled</span>
myPromise.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> thenValue = value; });
myPromise.thenSync(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> thenSyncValue = value; });
console.log(<span class="string">"thenValue = "</span> + thenValue);
console.log(<span class="string">"thenSyncValue = "</span> + thenSyncValue);

<span class="comment">// The result in the console is:</span>
<span class="comment">// thenValue = undefined</span>
<span class="comment">// thenSyncValue = 7</span></code></pre></div>
<p>Note that the behavior of <code>thenSync</code> only differs from the one of <code>then</code> if it is called on an already fulfilled or rejected promise.
In the following sample, both <code>then</code> and <code>thenSync</code> behave in the same way because the promise is still pending when <code>then</code> and <code>thenSync</code> are called:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> thenValue, thenSyncValue;
<span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
<span class="keyword">var</span> defer = Promise.defer();
<span class="keyword">var</span> myPromise = defer.promise;

<span class="comment">// myPromise is not yet fulfilled</span>
myPromise.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> thenValue = value; });
myPromise.thenSync(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> thenSyncValue = value; });

defer.resolve(<span class="number">7</span>); <span class="comment">// now it is fulfilled, but the handlers will be called asynchronously</span>
console.log(<span class="string">"thenValue = "</span> + thenValue);
console.log(<span class="string">"thenSyncValue = "</span> + thenSyncValue);

<span class="comment">// The result in the console is:</span>
<span class="comment">// thenValue = undefined</span>
<span class="comment">// thenSyncValue = undefined</span></code></pre></div>
<p>Note that <code>thenSync</code> is not (yet?) standard. There was a <a href="https://github.com/promises-aplus/promises-spec/issues/169">request</a> to better integrate
Promises/A+ specifications with synchronous code, but it was unfortunately rejected.</p>
<h3 id="promiseinstance-isfulfilled-and-promiseinstance-isrejected-">promiseInstance.isFulfilled() and promiseInstance.isRejected()</h3>
<p><strong>promiseInstance.isFulfilled() : Boolean</strong></p>
<p>Returns <code>true</code> if <code>promiseInstance</code> is fulfilled, and <code>false</code> otherwise.</p>
<p><strong>promiseInstance.isRejected() : Boolean</strong></p>
<p>Returns <code>true</code> if <code>promiseInstance</code> is rejected, and <code>false</code> otherwise.</p>
<p>If both <code>promiseInstance.isFulfilled()</code> and <code>promiseInstance.isRejected()</code> return <code>false</code>, the promise is still pending.
<code>promiseInstance.isFulfilled()</code> and <code>promiseInstance.isRejected()</code> never both return <code>true</code> for the same promise instance.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
Promise.resolve(<span class="number">7</span>).isFulfilled() <span class="comment">// returns true</span>
Promise.resolve(<span class="number">7</span>).isRejected() <span class="comment">// returns false</span>
Promise.reject(<span class="number">7</span>).isFulfilled() <span class="comment">// returns false</span>
Promise.reject(<span class="number">7</span>).isRejected() <span class="comment">// returns true</span>
Promise.defer().promise.isFulfilled() <span class="comment">// returns false</span>
Promise.defer().promise.isRejected() <span class="comment">// returns false</span></code></pre></div>
<h3 id="promiseinstance-result-">promiseInstance.result()</h3>
<p><strong>promiseInstance.result()</strong></p>
<p>If <code>promiseInstance</code> is fulfilled, <code>promiseInstance.result()</code> returns the fulfillment value.</p>
<p>If <code>promiseInstance</code> is rejected, <code>promiseInstance.result()</code> returns the rejection reason.</p>
<p>Otherwise (i.e. <code>promiseInstance</code> is still pending), <code>promiseInstance.result()</code> returns <code>undefined</code>.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
Promise.resolve(<span class="number">7</span>).result() <span class="comment">// returns 7</span>
Promise.reject(<span class="number">7</span>).result() <span class="comment">// returns 7</span>
Promise.defer().promise.result() <span class="comment">// returns undefined</span></code></pre></div>
<h2 id="request-utility">Request utility</h2>
<p>noderJS contains a small promises-based utility to make network requests:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">"noder-js/request"</span>);</code></pre></div>
<p>It is a simple wrapper around <a href="http://www.w3.org/TR/XMLHttpRequest">XMLHttpRequest</a> that hides some of the
differences between browsers and makes it easy to request files.</p>
<p><strong>request (url: String, options: Object) : Promise</strong></p>
<p>This method sends a request to the server for the specified url and returns a promise.</p>
<p>The options object is optional. Here is the list of accepted options:</p>
<div class='snippet'><pre><code class="lang-js">options : {
   headers : {
      <span class="comment">// Headers to be included in the request, for example:</span>
      <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>
   },
   data : <span class="string">"My Request is..."</span>, <span class="comment">// String - Body of the request</span>
   sync : <span class="literal">false</span>, <span class="comment">// Boolean - Specifies if the request is synchronous or not (default: false)</span>
   method : <span class="string">"POST"</span> <span class="comment">// String - Type of request (default: "GET")</span>
}</code></pre></div>
<p>Here is an example, which posts a json object to the server, and parses the response as json:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">"noder-js/request"</span>);

request(<span class="string">"/api/"</span>, {
   method: <span class="string">"POST"</span>,
   headers: {
     <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>
   },
   data: <span class="built_in">JSON</span>.stringify(myJsonObjectToSend)
}).then(<span class="function"><span class="keyword">function</span> <span class="params">(xhr)</span> {</span>
   <span class="comment">// Success callback</span>
   <span class="comment">// Parses the response as JSON:</span>
   <span class="keyword">var</span> responseText = xhr.responseText;
   <span class="keyword">var</span> responseJson = <span class="built_in">JSON</span>.parse(responseText);
   <span class="comment">// ...</span>
}).catch(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> {</span>
   <span class="comment">// error callback handling cases when either the request fails or parsing the response JSON fails</span>
   <span class="comment">// ...</span>
});</code></pre></div>
<p><strong>Note: this page is still in construction, the following sections are planned to be added:</strong></p>
<ul>
<li>Loader plugins</li>
<li>Context</li>
</ul>
</article>
				</div>
			</div>
		</section>
	</div>
	<footer id="footer">
		<section class="content legal">
			© 2012 Aria Templates is licensed under Apache 2.0 license. See our <a
				href="http://ariatemplates.com/license">licensing page</a>
		</section>
	</footer>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-29575860-4', 'ariatemplates.com');
		ga('send', 'pageview');
	</script>
</body>
</html>